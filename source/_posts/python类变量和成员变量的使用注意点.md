---
title: python类变量和成员变量的使用注意点
id: 1
categories:
  - Python
date: 2016-09-04 20:18:55
tags:
  - Python
---

之前在用python写一个项目，发现一个很恶心的bug，就是同由一个类生成的两个实例之间的数据竟然会相互影响，这让我非常不解。后来联想到java的类有类变量也有实例变量，因此翻阅了相关资料，发现python也有类似的类变量和实例变量，比如下面的代码中：
```python
class A:
    x = 0
    def __init__(self):
        self.y = 0
```
x就是类变量，y就是实例变量。

原则上是没有错的，但是实际用的时候就发现一些恶心的问题（也就是我找了三天的bug）。。。比如下面的代码：
```python
class A:
    x = []
    y = 0
    def __init__(self):
        pass

    def add(self):
        self.x.append('1')
        self.y+=1
a=A() 
print a.x,a.y
print A.x,A.y
a.add()
print a.x,a.y
print A.x,A.y
b=A() 
print b.x,b.y
print A.x,A.y
```
这里很明显x和y都是类变量，add的作用是分别对x和y做出修改。然后构造一个实例a，对实例a的值进行修改，最后构造实例b。

本以为这个结果是显而易见的，然而他输出的结果却是：
```
[] 0
[] 0
['1'] 1
['1'] 0
['1'] 0
['1'] 0
```
问题在哪？明明x和y都是类变量，在第二组print中为什么a.x和b.x一样，但是a.y和b.y就是不一样呢？

想了半天悟了一个道理。。。就是对于python来说，类变量的确是所有类共有的东西。但是那是在我们用的同一个引用的情况下，比如对于[]对象的append方法就是公用一个类变量了；但是对于赋值语句来说，如果在类中对类变量使用了赋值语句，那么python就会生成一个该对象的副本，以后的操作都是基于这个副本而不会对原来的类对象造成影响。这样就解释的通上面的现象了。

那么为了杜绝自己忘记类变量和实例变量的区别导致本不想公用变量的时候公用了变量，最好的办法就是在每个类中使用变量的时候重新初始化一下，这样就不会导致意外了。
