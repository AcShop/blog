---
title: 正则表达式基础（1）
id: 1
categories:
  - Others
date: 2015-11-24 23:32:54
mathjax: true
---

正则表达式这东西真的特别常用，在搜索文本啊，写爬虫什么的都得用到。而且现如今各种语言，都会支持正则表达式。之前也零零碎碎的看过，但是很多细节都记不清，这里姑且把一些知识要点记录下来，供日后查找使用。

## 通用的正则表达式


由于正则表达式有很多种实现方式，所以各种方式之间有一些区别。但是以下的一些条件，则是在任何语言的正则中都适用的规律：

|符号|匹配|
|-|-|
|^|匹配输入字符串开始的位置。|
|$|匹配输入字符串结尾的位置。|
|*|零次或多次匹配前面的字符或子表达式。例如，zo* 匹配“z”和“zoo”。* 等效于 {0,}。|
|+|一次或多次匹配前面的字符或子表达式。例如，“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}。|
|?|零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。|
|{_n_}|_n _是非负整数。正好匹配 _n_ 次。例如，“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。|
|{_n_,}|_n _是非负整数。至少匹配 _n _次。例如，“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o*”。|
|{_n_,_m_}|_M_ 和 _n_ 是非负整数，其中 _n_ <= _m_。匹配至少 _n_ 次，至多 _m_ 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。|
|?|当此字符紧随任何其他限定符（*、+、?、{_n_}、{_n_,}、{_n_,_m_}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。|
|.|匹配除“n”之外的任何单个字符。若要匹配包括“n”在内的任意字符，请使用诸如“[sS]”之类的模式。|
|_x_&vert; _y_|匹配 _x_ 或 _y_。例如，'z&vert;food' 匹配“z”或“food”。'(z&vert; f)ood' 匹配“zood”或“food”。|
|[_xyz_]|字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。|
|[^_xyz_]|反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。|
|[_a-z_]|字符范围。匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。|
|[^_a-z_]|反向范围字符。匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。|

这里是正则最基础的用法了，熟记这张表，平时就够用了。

当然，我们平时也会看到其他一些符号，比如下面这些类似的符号。

## 其他元字符

|符号|匹配|
|-|-|
|b|匹配一个字边界，即字与空格间的位置。例如，“erb”匹配“never”中的“er”，但不匹配“verb”中的“er”。|
|B|非字边界匹配。“erB”匹配“verb”中的“er”，但不匹配“never”中的“er”。|
|c_x_|匹配 _x_ 指示的控制字符。例如，cM 匹配 Control-M 或回车符。_x_ 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。|
|d|数字字符匹配。等效于 [0-9]。|
|D|非数字字符匹配。等效于 [^0-9]。|
|f|换页符匹配。等效于 x0c 和 cL。|
|n|换行符匹配。等效于 x0a 和 cJ。|
|r|匹配一个回车符。等效于 x0d 和 cM。|
|s|匹配任何空白字符，包括空格、制表符、换页符等。与 [ fnrtv] 等效。|
|S|匹配任何非空白字符。与 [^ fnrtv] 等效。|
|t|制表符匹配。与 x09 和 cI 等效。|
|v|垂直制表符匹配。与 x0b 和 cK 等效。|
|w|匹配任何字类字符，包括下划线。与“[A-Za-z0-9_]”等效。|
|W|与任何非单词字符匹配。与“[^A-Za-z0-9_]”等效。|

这些元字符也非常普遍，我之所以将他跟上面的通用字符分开，是因为这种类似Perl风格的正则表达式并不能被所有的工具识别。比如Linux下的egrep就无法识别这种表示方法。这就引入了下面的POSIX字符类。

## POSIX字符类
|符号|匹配|
|-|-|
|[:alnum:]|字母字符和数字字符；在ASCII码中，与[A-Za-z0-9]等效|
|[:word:]|基本与[:alnum:]一样，只是多了一个下划线字符(_)|
|[:alpha:]|字母字符；在ASCII中，等效于[A-Za-z]|
|[:blank:]|包括空格和制表符|
|[:cntrl:]|ASCII控制码；包括ASCII字符0~31以及127|
|[:digit:]|数字0~9|
|[:graph:]|可见字符；在ASCII中，包括字符33~126|
|[:lower:]|小写字母|
|[:punct:]|标点符号字符；在ASCII中，与[-!"#$%&'()*+,./:;<=>?@[\]_`{&vert;}~]等效|
|[:print:]|可打印字符；包括[:graph:]中的所有字符再加上空格字符|
|[:space:]|空白字符如空格符、制表符、回车符、换行符、垂直制表符以及换页符。在ASCII中，等效为[ trnvf]|
|[:upper:]|大写字母|
|[:xdigit:]|用于表示十六进制的字符；在ASCII中，与[0-9A-Fa-f]等效|

在使用的时候记得还要在外面包一层[  ]。比如匹配四个字母，可以写成 [[:alpha:]]{4}

这里之所以提到POSIX字符类，是因为在shell中无法使用d w 这类的元字符，只能使用POSIX字符类。

以上就是正则最基础的用法了。掌握这些就可以解决绝大多数的问题了。
