
## 第十一题
> 我们应该可以将流的结果并发收集到一个`ArrayList`中，而不是将多个`ArrayList`合并起来。由于对集合不相交部分的并发操作是线程安全的，所以我们假设这个`ArrayList`的初始大小即为流的大小。如何能做到这一点？

这题没怎么看懂，好像就是考察原子类。。。
```java
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

public class Task11 {

    public void task11() throws IOException {
        Stream<String> stream = Stream.of("1", "2", "3", "4", "5");
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            list.add("");
        }

        AtomicInteger atomic = new AtomicInteger();
        stream.parallel().forEach(x -> {
            list.set(atomic.getAndIncrement(), x);
        });
        list.forEach(System.out::println);
    }

    public static void main(String[] args) throws IOException {
        new Task11().task11();
    }
}
```

## 第十二题
> 如第2.13节所示，通过更新一个`AtomicInteger`数组来计算一个并行`Stream<String>`宏的所有短单词。使用原子操作方法getAndIncreament来安全的增加每个计数器的值。

简单考察原子类操作。
```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Stream;

public class Task12 {

    public void task12() throws IOException {
        String contents = new String(Files.readAllBytes(Paths.get("article.txt")), StandardCharsets.UTF_8);
        Stream<String> words = Stream.of(contents.split("[\\P{L}]+"));
        AtomicInteger count = new AtomicInteger();
        words.parallel().forEach(x -> {
            if (x.length() < 12) {
                count.getAndIncrement();
            }
        });
        System.out.println(count.get());
    }

    public static void main(String[] args) throws IOException {
        new Task12().task12();
    }
}

```

## 第十三题
> 重复上一个练习，这次使用collect方法、Collectors.groupingBy方法和Collectors.counting方法来过滤出短单词。

巩固Collectors的分组方法等。
```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Task13 {

    public void task13() throws IOException {
        String contents = new String(Files.readAllBytes(Paths.get("article.txt")), StandardCharsets.UTF_8);
        Stream<String> words = Stream.of(contents.split("[\\P{L}]+"));

        long count = words.parallel()
                .unordered()
                .collect(Collectors.groupingBy(x -> x.length() < 12, Collectors.counting()))
                .get(true);
        System.out.println(count);
    }

    public static void main(String[] args) throws IOException {
        new Task13().task13();
    }
}

```

## 参考资料
[Java SE 8 for the Really Impatient](https://doc.lagout.org/programmation/Java/Java%20SE%208%20for%20the%20Really%20Impatient%20%5BHorstmann%202014-01-24%5D.pdf)
[Answers found in github](https://github.com/DanielChesters/java-SE-8-Really-Impatient)
